package conform

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig"
	"github.com/autonomy/conform/conform/config"
	"github.com/autonomy/conform/conform/git"
)

// Enforcer performs all the build actions for a rule.
type Enforcer struct {
	config  *config.Config
	rule    string
	GitInfo *git.Info
	Built   string
}

// NewEnforcer instantiates and returns an executer.
func NewEnforcer(rule string) (*Enforcer, error) {
	e := &Enforcer{}
	gitInfo := git.NewInfo()
	date := []byte{}
	if gitInfo.IsTag {
		_date, err := exec.Command("date").Output()
		if err != nil {
			fmt.Print(err)
		}

		date = _date
	}

	c, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	e.config = c
	e.GitInfo = gitInfo
	e.Built = strings.TrimSuffix(string(date), "\n")
	e.rule = rule

	return e, nil
}

// ExecuteBuild executes a docker build.
func (e *Enforcer) ExecuteBuild() error {
	image := e.FormatImageNameSHA()
	if e.GitInfo.IsDirty {
		image = e.FormatImageNameDirty()
	}

	os.Setenv("CONFORM_IMAGE", image)

	args := append([]string{"build", "--tag", image, "."})
	command := exec.Command("docker", args...)
	command.Stdout = os.Stdout
	command.Stderr = os.Stderr
	command.Start()
	err := command.Wait()
	if err != nil {
		return err
	}

	return nil
}

// RenderDockerfile writes the final Dockerfile to disk.
func (e *Enforcer) RenderDockerfile(target *config.Rule) error {
	dockerfile := `# THIS FILE IS AUTOGENERATED BY CONFORM. DO NOT EDIT!
# Note: This file should be ignored by git.
  `
	for _, p := range target.Templates {
		r, err := e.RenderTemplate(p)
		if err != nil {
			return err
		}
		dockerfile = dockerfile + "\n" + *r
	}

	if e.config.Debug {
		fmt.Println(dockerfile)
	} else {
		ioutil.WriteFile("Dockerfile", []byte(dockerfile), 0644)
	}

	return nil
}

// RenderTemplate executes the template and returns it.
func (e *Enforcer) RenderTemplate(s string) (*string, error) {
	if _s, ok := e.config.Templates[s]; ok {
		var wr bytes.Buffer
		tmpl, err := template.New("").Funcs(sprig.TxtFuncMap()).Parse(_s)
		if err != nil {
			return nil, err
		}

		err = tmpl.Execute(&wr, &e)
		if err != nil {
			return nil, err
		}

		str := wr.String()
		return &str, nil
	}

	return nil, fmt.Errorf("Template %q is not defined in conform.yaml", s)
}

// ExtractArtifact copies an artifact from a build.
func (e *Enforcer) ExtractArtifact(artifact string) error {
	return fmt.Errorf("Artifact %q is not defined in conform.yaml", artifact)
}

// ExecuteScript executes a script for a rule.
func (e *Enforcer) ExecuteScript(script string) error {
	if s, ok := e.config.Scripts[script]; ok {
		log.Printf("Running %s script", script)
		command := exec.Command("bash", "-c", s)
		command.Stdout = os.Stdout
		command.Stderr = os.Stderr
		command.Start()
		err := command.Wait()
		if err != nil {
			return err
		}

		return nil
	}

	return fmt.Errorf("Script %q is not defined in conform.yaml", script)
}

// ExecuteRule performs all the relevant actions specified in its' declaration.
func (e *Enforcer) ExecuteRule() error {
	if t, ok := e.config.Rules[e.rule]; ok {
		log.Printf("Enforcing %q", e.rule)
		for _, s := range t.Before {
			err := e.ExecuteScript(s)
			if err != nil {
				return err
			}
		}
		err := e.RenderDockerfile(t)
		if err != nil {
			return err
		}
		err = e.ExecuteBuild()
		if err != nil {
			return err
		}
		for _, s := range t.After {
			err := e.ExecuteScript(s)
			if err != nil {
				return err
			}
		}

		return nil
	}

	return fmt.Errorf("Rule %q is not defined in conform.yaml", e.rule)
}

// FormatImageNameDirty formats the image name.
func (e *Enforcer) FormatImageNameDirty() string {
	return fmt.Sprintf("%s:%s", *e.config.Metadata.Repository, "dirty")
}

// FormatImageNameSHA formats the image name.
func (e *Enforcer) FormatImageNameSHA() string {
	return fmt.Sprintf("%s:%s", *e.config.Metadata.Repository, e.GitInfo.SHA)
}

// FormatImageNameTag formats the image name.
func (e *Enforcer) FormatImageNameTag() string {
	return fmt.Sprintf("%s:%s", *e.config.Metadata.Repository, e.GitInfo.Tag)
}

// FormatImageNameLatest formats the image name.
func (e *Enforcer) FormatImageNameLatest() string {
	return fmt.Sprintf("%s:%s", *e.config.Metadata.Repository, "latest")
}
